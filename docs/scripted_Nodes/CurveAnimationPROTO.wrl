#VRML V2.0 utf8

PROTO CurveAnimation
#
# works at least with InstantPlayer
#
# A VRML Proto to account the data for a PositionInterpolator and a 
# OrientationInterpolator from NurbsCurve data by scripting 
# (slow)
# Copyright (C) 2006 J. "MUFTI" Scheurich
#
# Developed from NodeNurbsSurface.cpp of the vrml97 editor dune 
# Copyright (C) 1999 Stephen F. White
#
# exampe use
#
# EXTERNPROTO CurveAnimation
#    [
#    eventIn      SFFloat    set_fraction
#    eventOut     SFVec3f    position_changed
#    eventOut     SFRotation orientation_changed
#    exposedField MFVec3f    controlPoint        
#    exposedField SFInt32    tessellation        
#    exposedField MFFloat    weight              
#    field        MFFloat    knot                
#    field        SFInt32    order               
#    exposedField SFVec3f    rotationAxis
#    exposedField SFBool     enableRotation
#    exposedField SFBool     hover
#    ]
# [
# "CurveAnimationPROTO.wrl"
# ]
# 
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program (see the file "COPYING" for details); if 
# not, write to the Free Software Foundation, Inc., 675 Mass Ave, 
# Cambridge, MA 02139, USA.
#
   [
   eventIn      SFFloat    set_fraction
   eventOut     SFVec3f    position_changed
   eventOut     SFRotation orientation_changed
   exposedField MFVec3f    controlPoint          []
   exposedField SFInt32    tessellation          0      # (-&infin;,&infin;)
   exposedField MFFloat    weight                []     # (0,&infin;)
   field        MFFloat    knot                  []     # (-&infin;,&infin;)
   field        SFInt32    order                 3      # [2,&infin;) 
   exposedField SFVec3f    rotationAxis          0 1 0
   exposedField SFBool     enableRotation        TRUE  
   exposedField SFBool     hover                 TRUE
   ]
{
Group
  {
  children
    [
    DEF POSITION_INTERPOLATOR PositionInterpolator 
      {
      value_changed IS position_changed
      }
    DEF ORIENTATION_INTERPOLATOR OrientationInterpolator 
      {
      value_changed IS orientation_changed
      }
    ]
  }

# nodes switched off, not rendered cause not part of the scenegraph anyway ....
Switch 
  {
  choice 
    [
    Shape 
      {
      geometry IndexedFaceSet 
        {
        coord DEF NURBS_CONTROLPOINT_CONTAINER Coordinate 
          {
          point IS controlPoint
          }
        }
      }
    DEF NURBS_TESSELLATION_CONTAINER Switch 
      {
      whichChoice IS tessellation
      }
    DEF NURBS_WEIGHT_CONTAINER Text
      {
      length IS weight
      }
    DEF BOOL_CONTAINER Collision
      {
      collide IS enableRotation
      }
    DEF AXIS_CONTAINER Transform 
      {
      translation IS rotationAxis
      }
    ]
  }

DEF NURBS_SCRIPT Script 
  {
  directOutput TRUE  

  eventIn SFFloat set_fraction IS set_fraction
  eventOut SFFloat set_fraction_out

  field SFNode controlPoint_container USE NURBS_CONTROLPOINT_CONTAINER
  eventIn MFVec3f controlPoint_in
  eventOut MFVec3f controlPoint_out
  field MFVec3f controlPoint [] 

  field SFNode tessellation_container USE NURBS_TESSELLATION_CONTAINER
  eventIn SFInt32 tessellation_in 
  eventOut SFInt32 tessellation_out 
  field SFInt32 tessellation 0

  field SFNode weight_container USE NURBS_WEIGHT_CONTAINER
  eventIn MFFloat weight_in
  eventOut MFFloat weight_out
  field MFFloat weight []

  field MFFloat knot IS knot
  field SFInt32 order IS order

  field SFNode axis_container USE AXIS_CONTAINER
  eventIn SFVec3f rotationAxis_in
  eventOut SFVec3f rotationAxis_out
  field SFVec3f rotationAxis 0 1 0

  field SFNode bool_container USE BOOL_CONTAINER
  eventIn SFBool enableRotation_in
  eventOut SFBool enableRotation_out
  field SFBool enableRotation TRUE

  eventOut MFFloat positionKey
  eventOut MFVec3f positionKeyValue

  eventOut MFFloat orientationKey
  eventOut MFRotation orientationKeyValue

  field MFFloat weights []
  field MFVec3f tess []
  field MFFloat w []
  field MFVec2f tc []
  field MFInt32 ci []

  field MFFloat basis []
  field MFFloat deriv []

  field SFVec3f s 0 0 0
  field SFVec3f u 0 0 0

  field SFVec3f n 0 0 0

  field MFFloat left []
  field MFFloat right []

  field SFInt32 dimension 0
  url 
    [
    "javascript:

    function findSpan(dimension, order, u, knots) {
       var low;
       var mid;
       var high;
       var n;

       n = dimension + order - 1;

       if (u >= knots[n]) {
           return n - order;
       }
       low = order - 1;
       high = n - order + 1;

       mid = Math.floor((low + high) / 2);

       while ((u < knots[mid]) || (u >= knots[mid+1])) {
           if (u < knots[mid])
               high = mid;
           else
               low = mid;
           mid = Math.floor((low + high) / 2);
       }

       return Math.floor(mid);
    }

    function basisFuns(span, u, order, knots, basis, deriv) {
       var j;
       var saved;
       var dsaved;
       var r;
       var temp;

       basis[0] = 1.0;
       for (j = 1; j < order; j++) {
           left[j] = u - knots[span+1-j];
           right[j] = knots[span+j]-u;
           saved = 0.0;
           dsaved = 0.0;
           for (r = 0; r < j; r++) {
               temp = basis[r] / (right[r+1] + left[j-r]);
               basis[r] = saved + right[r+1] * temp;
               deriv[r] = dsaved - j * temp;
               saved = left[j-r] * temp;
               dsaved = j * temp;
           }
	   basis[j] = saved;
	   deriv[j] = dsaved;
       }
    }


    function linePoint(weight,u,ind) {
       var i;
       var j;

       var span;

       var base;

       var index;

       var w;
       var dw;

       var gain;
       var dgain;

       span = findSpan(dimension, order, u, knot);

       basisFuns(span, u, order, knot, basis, deriv);

       base = span-order+1;

       index = base;

       s=new SFVec3f(0.0, 0.0, 0.0);
       du=new SFVec3f(0.0, 0.0, 0.0);
       dv=new SFVec3f(0.0, 0.0, 0.0);
       w = 0.0;
       dw = 0.0;
       for (i = 0; i < order; i++) {
           gain = basis[i];
           dgain = deriv[i];
           s.x += controlPoint[index].x * gain;
           s.y += controlPoint[index].y * gain;
           s.z += controlPoint[index].z * gain;
           w += weight[index] * gain;
           du.x += controlPoint[index].x * dgain;
           du.y += controlPoint[index].y * dgain;
           du.z += controlPoint[index].z * dgain;
           dw += weight[index] * dgain;
           index++;
       }
       s.x = s.x / w;
       s.y = s.y / w;
       s.z = s.z / w;
       n.x = (du.x - s.x * dw) / w;
       n.y = (du.y - s.y * dw) / w;
       n.z = (du.z - s.z * dw) / w;
       return s;
    }


    function newQuat(x, y, z, a) {
       var r;
       r = new MFFloat();
       r[0] = x;
       r[1] = y;
       r[2] = z;
       r[3] = a;
       return r;
    }

    function quatNorm(quat) {
       var rlen;
       rlen = Math.sqrt(quat[0] * quat[0] + quat[1] * quat[1] + 
                        quat[2] * quat[2] + quat[3] * quat[3]);
       if (rlen > 0.000001)
          rlen = 1.0 / rlen;
       else
          rlen = 1.0;
       quat[0] *= rlen;
       quat[1] *= rlen;
       quat[2] *= rlen;
       quat[3] *= rlen;
    }

    function quatMult(q1, q2) {
       var r;
       r = newQuat(0, 0, 1, 0);
       r[0] = q2[3] * q1[0] + q2[0] * q1[3] + q2[1] * q1[2] - q2[2] * q1[1];
       r[1] = q2[3] * q1[1] + q2[1] * q1[3] + q2[2] * q1[0] - q2[0] * q1[2];
       r[2] = q2[3] * q1[2] + q2[2] * q1[3] + q2[0] * q1[1] - q2[1] * q1[0];
       r[3] = q2[3] * q1[3] - q2[0] * q1[0] - q2[1] * q1[1] - q2[2] * q1[2];
       quatNorm(r);
       return r;
    }

    function accountAngle(vec1, vec2) {
       var vec1len;
       var vec2len;
       var sinangle;
       var cosangle;
       var angle;
      
       vec1len = vec1.length();
       vec2len = vec2.length();
       if ((vec1len == 0) || (vec2len == 0))
          return 0;
       sinangle = vec1.cross(vec2).length() / vec1len / vec2len;
       cosangle = vec1.dot(vec2) / vec1len / vec2len;
       if (sinangle < 1e-9)
          return 0;
       angle = Math.atan2(sinangle, cosangle);

       return angle;
    }


    function accountProjection(vector, normal) {
       var angle;
       var mult;

       angle = accountAngle(vector, normal);
       mult = vector.length() * Math.cos(angle);
       return new SFVec3f(vector.x - normal.x * mult,
                          vector.y - normal.y * mult,
                          vector.z - normal.z * mult);
    }

    function accountQuat(vec1, vec2) {
       var rotAxis;
       var axis;
       var axisLength;
       var rot;
       var angle;
       var sinAngle;

       rotAxis = vec1.cross(vec2);
       axisLength = rotAxis.length;
       if (axisLength == 0)
          axis = new SFVec3f(0, 0, 0);
       else 
          axis = new SFVec3f(rotAxis.x / axisLength, 
                             rotAxis.y / axisLength, 
                             rotAxis.z / axisLength);
       angle = accountAngle(vec1, vec2);
       sinAngle = Math.sin(0.5 * angle);
       rot = newQuat(axis.x * sinAngle, axis.y * sinAngle, axis.z * sinAngle, 
                     Math.cos(0.5 * angle));
       quatNorm(rot);
       return rot;
    }

    function sendToOrientationInterpolator() {
       var i;
       var j;
       var chainLength;
       var chainRot;
       var oldQuat;
       var correctionX;
       var correctionY;
       var normal;
       var vector1;
       var point3;
       var point2;
       var vector2;
       var vec1;
       var vec2
       var quat;
       var rlen;
       var axis;
       var rot;

       if (tess.length == 0) 
          makeChain();

       chainLength = tess.length;
       if (chainLength < 1)
          return;
       chainRot = new MFFloat(chainLength * 4);
       correctionX = newQuat(1, 0, 0, Math.cos(0.5 * Math.PI));
       correctionY = newQuat(0, 1, 0, Math.cos(0.5 * Math.PI));
       oldQuat = newQuat(0, 0, 1, 0);
       for (j = 0; j < (chainLength - 1); j++) {
          normal = rotationAxis;
          vector1 = new SFVec3f(0, 0, 1);
          point3 = new SFVec3f (tess[j + 1].x,  tess[j + 1].y, tess[j + 1].z);
          point2 = new SFVec3f (tess[j    ].x,  tess[j    ].y, tess[j    ].z);
          if (j > 0) {
             point1 = new SFVec3f(tess[j - 1].x,  tess[j - 1].y, tess[j - 1].z);
             vector1 = new SFVec3f(point2.x - point1.x,
                                   point2.y - point1.y,
                                   point2.z - point1.z);
          }
          vector2 = new SFVec3f(point3.x - point2.x,
                                point3.y - point2.y,
                                point3.z - point2.z);
          vec1 = accountProjection(vector1, normal);
          vec2 = accountProjection(vector2, normal);
          quat = accountQuat(vec1, vec2);
          quat = quatMult(quat, oldQuat);
          if (j == 0) {
             quat = quatMult(quat, correctionY); 
             quat = quatMult(quat, correctionX); 
          }
          rlen = Math.sqrt(quat[0] * quat[0] + quat[1] * quat[1] + 
                           quat[2] * quat[2]);
          axis = new SFVec3f(quat[0], quat[1], quat[2]); 
          axis.normalize();
          rot = new SFRotation(axis, 2.0 * Math.acos(quat[3]));
          for (i = 0; i < 4; i++)
             chainRot[j * 4 + i] = rot[i];
          oldQuat = quat;
       }    

       if (chainLength > 0) {
          for (i = 0; i < 4; i++)
             chainRot[(chainLength - 1) * 4 + i] =  oldQuat[i];
       }
       orientationInterpolator.key = new MFFloat();
       orientationInterpolator.keyValue = new MFRotation();
       for (i = 0; i < tess.length; i++) {
           if (tess.length == 1)
               orientationKey[i] = 0;
           else
               orientationKey[i] = (1.0 / (tess.length - 1)) * i;
           orientationKeyValue[i].x = chainRot[i * 4];
           orientationKeyValue[i].y = chainRot[i * 4 + 1];
           orientationKeyValue[i].z = chainRot[i * 4 + 2];
           orientationKeyValue[i].angle = chainRot[i * 4 + 3];

       }
    }

    function sendToPositionInterpolator() {
       positionKey = new MFFloat();
       positionKeyValue = new MFVec3f();
       for (i = 0; i < tess.length; i++) {
           if (tess.length == 1)
               positionKey[i] = 0;
           else
               positionKey[i] = (1.0 / (tess.length - 1)) * i;
           positionKeyValue[i].x = tess[i].x;
           positionKeyValue[i].y = tess[i].y;
           positionKeyValue[i].z = tess[i].z;
       }
    }
  
    function makeChain() {
       var size;
       var i;
       var j;
       var index;
       var u;
       var inv;
       var inc;
       var uTess;        

       index=0;

       weights = new MFFloat();

       dimension = order;

       if (dimension == 0) return;

/*
       if (knot.length != order + dimension) {
           print('no NurbsCurve: knot.length!=order+dimension');
           return;
       }
*/
   
       if (weight.length == 0) {
          weights = new MFFloat();
          for (i = 0; i < controlPoint.length; i++) {
               weights[i] = 1.0;
          }
       } else if (weight.length != controlPoint.length) {
           print('no NurbsCurve: weight.length!=controlPoint.length');
           return;
       }
   
       uTess=tessellation;

       if (uTess <= 0) uTess = 32;

       tess = new MFVec3f();

       size = (uTess + 1);
   
       if (knot.length != 0)
           inc = (knot[knot.length-1] - knot[0]) / uTess;
       else
           print('knot.length = 0 ');

       w = (weight.length == 0) ? weights : weight;
       u = knot[0];

       for (i = 0; i <= uTess; i++) {
           tess[i] = linePoint(w,u,i);
           index++;
           u += inc;
       }

       sendToPositionInterpolator();
       sendToOrientationInterpolator();
    }

    function initialize() {
       controlPoint=controlPoint_container.point;
       weight=weight_container.length;
       tessellation=tessellation_container.whichChoice;
       makeChain();
    }

    function controlPoint_in(value, time) {
       controlPoint=value;
       controlPoint_out=value;
       makeChain();
    }    

    function weight_in(value, time) {
       weight=value;
       weight_out=value;
       makeChain();
    }
    
    function tessellation_in(value, time) {
       tessellation=value;
       tessellation_out=value;
       makeChain();
    }

    function set_fraction(value, time) {
       rotation_axis = axis_container.translation;
       enableRotationField = bool_container.collide;
       set_fraction_out = value;
    }

    function rotationAxis_in(value, time) {
       rotationAxis = value;
       rotationAxis_out=value;
       makeChain();
    }

    function enableRotation_in(value, time) {
       enableRotation = value;
       enableRotation_out=value;
       makeChain();
    }
    "
   ]
   }

   ROUTE NURBS_CONTROLPOINT_CONTAINER.point TO NURBS_SCRIPT.controlPoint_in
   ROUTE NURBS_WEIGHT_CONTAINER.length TO NURBS_SCRIPT.weight_in
   ROUTE NURBS_TESSELLATION_CONTAINER.whichChoice TO NURBS_SCRIPT.tessellation_in
   ROUTE AXIS_CONTAINER.translation TO NURBS_SCRIPT.rotationAxis_in
   ROUTE BOOL_CONTAINER.collide TO NURBS_SCRIPT.enableRotation_in

   ROUTE NURBS_SCRIPT.set_fraction_out TO POSITION_INTERPOLATOR.set_fraction
   ROUTE NURBS_SCRIPT.positionKey TO POSITION_INTERPOLATOR.key
   ROUTE NURBS_SCRIPT.positionKeyValue TO POSITION_INTERPOLATOR.keyValue

   ROUTE NURBS_SCRIPT.set_fraction_out TO ORIENTATION_INTERPOLATOR.set_fraction
   ROUTE NURBS_SCRIPT.orientationKey TO ORIENTATION_INTERPOLATOR.key
   ROUTE NURBS_SCRIPT.orientationKeyValue TO ORIENTATION_INTERPOLATOR.keyValue
   
#   ROUTE NURBS_SCRIPT.controlPoint_out TO NURBS_CONTROLPOINT_CONTAINER.coord
#   ROUTE NURBS_SCRIPT.weight_out TO NURBS_WEIGHT_CONTAINER.length
#   ROUTE NURBS_SCRIPT.tessellation_out TO NURBS_TESSELLATION_CONTAINER.whichChoice
#   ROUTE NURBS_SCRIPT.rotationAxis_out TO AXIS_CONTAINER.translation
#   ROUTE NURBS_SCRIPT.enableRotation_out TO BOOL_CONTAINER.collide
}

